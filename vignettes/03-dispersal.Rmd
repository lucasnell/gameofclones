---
title: "Estimating dispersal"
author: "Lucas A. Nell"
date: "2018-07-03"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating dispersal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
```

```{r library_pkgs, warning=FALSE, echo=TRUE}
set.seed(6514651)
suppressPackageStartupMessages({
    library(MASS)
    library(clonewars)
    library(lme4)
})
logit <- function(p) {
    suppressWarnings({x <- log(p/(1 - p))})
    # x <- ifelse(is.nan(x), NA, x)
    return(x)
}
inv_logit <- function(x) {
    p <- 1 / (1 + exp(-x))
    p <- ifelse(is.na(p) & !is.na(x), 1, p)
    return(p)
}
```


This file contains the analyses to estimate aphid dispersal.



## Load data

I don't need to do the same filtering when loading the dataset for dispersal estimates
as when loading data for population-growth parameter estimation.
The only filtering I need to do is removing the first day of counts when both
individuals were on the ground.


```{r load_data}
growth <- load_data(filter_pars = NULL,
                    remove_unfinished = FALSE) %>% 
    filter(date != 0) %>% 
    mutate(rep = factor(rep)) %>%
    group_by(line, rep) %>% 
    arrange(date) %>% 
    mutate(disp = ifelse(is.na(disp), 0, disp),
           X = impute(X),
           N = round(exp(X)),
           X = log(N),
           pN = N - disp,  # numbers of aphids on plant
           dD = disp - lag(disp, default = 0), # number of new dispersed aphids
           dD = ifelse(dD < 0, 0, dD),
           past_death = date - which(N == max(N))[1], # days past plant death
           disp_b = ifelse(dD == 0, 0, 1)) %>% 
    ungroup() %>% 
    arrange(line, rep, date) %>% 
    identity()
```


## View sample sizes

Below, `n_d` is the number of days where the number of dispersed individuals was
greater than zero.

```{r n_d_table}
growth %>% 
    group_by(line) %>% 
    summarize(n = rep %>% unique() %>% length(),
              n_d = sum(disp > 0)) %>% 
    knitr::kable()
```



## Dispersal ~ N plot

Below, colors represent different reps.


```{r disp_N_plot, warning=FALSE}

growth %>%
    {mutate(., pred = glm(dD ~ line + offset(X), family = "poisson", 
                      data = growth) %>% predict(type = "response"))} %>% 
    ggplot(aes(N)) +
    geom_point(aes(y = dD, color = rep), shape = 16, alpha = 0.75) +
    geom_line(aes(y = pred), color = "black", shape = 1, alpha = 0.75) +
    facet_wrap(~ line) +
    scale_color_brewer(palette = "Set3", guide = FALSE) +
    NULL
```


## Fitting GLMs

Fitting a Poisson GLM of `<# new dispersed> ~ line + offset(log(N))`.


```{r fit_glmm, warning=FALSE}
disp_pois <- glm(dD ~ 0 + line + offset(X), family = "poisson", data = growth)
```

Estimates for each line:


```{r make_disp_mod_df, echo = FALSE}
disp_estimates <- disp_pois %>% 
    coef() %>% 
    cbind() %>% 
    as.data.frame() %>% 
    set_names("b0") %>% 
    rownames_to_column("line") %>% 
    mutate(line = gsub("line", "", line))
disp_estimates %>% 
    knitr::kable(
        digits = 3
        )
```




Code to make predictions from both models based on a vector of `N` and aphid line
names:

```{r prediction_fxn}
predict_disp <- function(N, aphid_line) {
    inds <- map_int(aphid_line, ~ which(disp_estimates$line == .x))
    b0 <- disp_estimates$b0[inds]
    lambda_ <- exp(b0) * N
    return(lambda_)
}
```


## Plotting predictions

```{r glmm_prediction_plot}
growth %>% 
    ggplot(aes(N, dD, color = rep)) +
    geom_point(alpha = 0.75, shape = 16) +
    geom_line(data = expand.grid(N = 1:1000,
                                 line = growth$line %>% unique() %>% sort()) %>% 
                  mutate(dD = predict_disp(N, line)),
        size = 0.75, color = "black") +
    scale_color_brewer(palette = "Set3", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    scale_y_continuous("Dispersed aphids", trans = "log1p",
                       breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    NULL
```


## Testing simulation

```{r sim_disp}
sim_disp <- function(N, aphid_line) {
    inds <- map_int(aphid_line, ~ which(disp_estimates$line == .x))
    b0 <- disp_estimates$b0[inds]
    lambda_ <- exp(b0) * N
    # Generate random numbers:
    n <- length(N)
    pois_rnd <- rpois(n, lambda = lambda_)
    return(pois_rnd)
}
```



```{r dispersal_compare_plots}
growth %>% 
    mutate(disp_ = sim_disp(N, line)) %>% 
    ggplot(aes(X, disp_, color = rep)) +
    geom_point(alpha = 0.75, shape = 16) +
    scale_color_brewer(palette = "Set3", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    ggtitle("Simulated dispersal") +
    scale_y_continuous("Dispersed aphids", trans = "log1p",
                       breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    NULL
# Other one to compare to:
growth %>% 
    ggplot(aes(X, dD, color = rep)) +
    geom_point(alpha = 0.75, shape = 16) +
    scale_color_brewer(palette = "Set3", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    ggtitle("Actual dispersal") +
    scale_y_continuous("Dispersed aphids", trans = "log1p",
                       breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    NULL


sim_accuracy <- map(1:100, ~ sim_disp(growth$N, growth$line)) %>% 
    map_dfr(~ data_frame(mu = mean(.x), sig = sd(.x))) %>% 
    gather("par", "value", factor_key = TRUE)
    
sim_accuracy %>% 
    ggplot(aes(value, fill = par)) +
    geom_histogram(bins = 20) +
    geom_vline(data = data_frame(par = c("mu", "sig"), 
                                 value = c(mean(growth$dD), sd(growth$dD))),
               aes(xintercept = value), linetype = 2) +
    facet_wrap(~ par, scales = "free") +
    scale_fill_brewer(palette = "Dark2", guide = FALSE)
```



## Saving output

```{r save_output, eval = FALSE}
devtools::use_data(disp_estimates, overwrite = TRUE)
```


