---
title: "Choosing priors"
author: "Lucas A. Nell"
date: "2018-07-04"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Choosing priors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4,
  echo = FALSE
)
# knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 4L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
```



```{r library_pkgs, warning=FALSE}
set.seed(196534)
suppressPackageStartupMessages({
    library(clonewars)
})
bayesplot::color_scheme_set("viridis")
dlnorm_ <- function(x, location, scale) {
    dlnorm(x, meanlog = location, sdlog = scale)
}
```


This document outlines how I created my prior values.
See `vignette("Model description")` for my model description.
In general, my goal is to create weakly informative prior distributions:

> We characterize a prior distribution as *weakly informative* if it is proper but
> is set up so that the information it does provide is intentionally weaker
> than whatever actual prior knowledge is available. (p 55, Gelman et al. 2014)

Gelman, A., J. B. Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, and D. B. Rubin. 2014.
*Bayesian Data Analysis*. Third edition. CRC Press, Boca Raton, FL, USA.






## Process error priors

```{r define_process_priors}
# Below are meanlog and sdlog parameters for the log-normal distribution
# that generates values for the process error standard deviation
tau <- signif(log(0.15), 4)
sigma_tau <- 1
```


$s_\varepsilon$ is bound $\ge 0$ and sampled as $\sim \text{Lognormal}(\tau, \sigma_\tau)$
Based on simulations, an $s_\varepsilon$ of 1 would be very high---so high as to be not
realistically possible.
Values of ~ 0.15 seemed to result in simulations matching some preliminary experimental
results we've seen in the lab.
Below, `r sprintf('"sigma%.2f"', tau)` is simulated data with process error set to
`r tau`, "sigma1" has process error set to 1.0.
The others are the preliminary data.

```{r load_prior}
load_prior_data() %>% 
    add_row(line = paste0("sigma", signif(exp(tau), 2)), rep = rep(1:5, each=16),
            date = rep(5:20,5),
            X = sim_lines(R = 0.2, alpha = 1/1000, n_reps = 5, nobs_ts = rep(16, 5), 
                          sigma_process = exp(tau)) %>% 
                as.numeric()) %>% 
    add_row(line = "sigma1", rep = rep(1:5, each=16), date = rep(5:20,5),
            X = sim_lines(R = 0.2, alpha = 1/1000, n_reps = 5, nobs_ts = rep(16, 5), 
                          sigma_process = 1) %>% 
                as.numeric()) %>% 
    mutate(rep = factor(rep)) %>% 
    ggplot(aes(date, X)) +
    geom_line(aes(color = rep)) +
    facet_wrap(~ line) +
    scale_color_brewer(palette = "Dark2", guide = FALSE)
```


To sample $s_\varepsilon$,
I chose a log-normal distribution with `log(0.15)` (`r tau`) as the
$tau$ and `r sigma_tau` for $\sigma_\tau$ because this results in low densities at values
close to 1.
Note that below, the x-axis is log-transformed, but axis labels indicate 
non-transformed values.

```{r process_error_plot}
compare_priors("normal", tau, sigma_tau, xlim = tau + c(-1,1) * 3.25) +
    geom_vline(xintercept = tau) +
    ggtitle(expression(s[epsilon] %~% plain("Lognormal")(tau * "," ~ sigma[tau]))) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_tau)) +
    scale_x_continuous(breaks = log(c(1 * 10^(-2:0), 0.05, 0.5)),
                       labels = c(1 * 10^(-2:0), 0.05, 0.5)) +
    NULL
```






## Growth rate priors


From data sent to me from A.R. Ives related to this paper:

Meisner, M. H., J. P. Harmon, and A. R. Ives. 2014. Temperature effects on
long-term population dynamics in a parasitoid–host system.
*Ecological Monographs* __84__:457–476.

For fecundity, juvenile survival, and adult survival, the dataset had low and high
estimates.
I created two Leslie matrices, one with all of the high estimates and another
with all the lower estimates.
For each of these Leslie matrices, I estimated the intrinsic daily rate of increase
($r$) in aphid populations in the lab as $r = \log(\lambda)$, where $\lambda$ is the
dominant eigenvector of the matrix.
Thus I have fast and slow estimates of population growth to use as prior information
about our population-growth assays.


```{r load_leslies}
fast <- clonewars::leslie %>% 
    .[["fast"]] %>% 
    eigen() %>% 
    .[["values"]] %>% 
    .[1] %>% 
    Re() %>% 
    log()
slow <- clonewars::leslie %>% 
    .[["slow"]] %>% 
    eigen() %>% 
    .[["values"]] %>% 
    .[1] %>% 
    Re() %>% 
    log()
cat(sprintf("fast = %.4g\n", fast))
cat(sprintf("slow = %.4g\n", slow))
```



\begin{align}
    
    \mathbf{R}_i &= \exp \left( \theta + s_\theta ~ Z \right) \\
    
    \theta &= \mu_{\theta} + \sigma_{\theta} ~ Z \\
    s_\theta &= \exp(\gamma + \sigma_\gamma ~ Z) \\
    
\end{align}


```{r define_R_priors}
# mean and SD  of the normal distribution that generates theta values
#   (theta = among-line mean of the log-transformed growth rates)
mu_theta <- c(fast, slow) %>% 
    log() %>% 
    mean() %>% 
    signif(4)
sigma_theta <- c(fast, slow) %>%
    log() %>% 
    sd() %>% 
    `*`(., 10) %>% 
    signif(4)

# meanlog and sdlog parameters for the log-normal distribution that generates
#   s_theta values
#   (s_theta = among-line standard deviation of the log-transformed growth rates)
gamma <- c(fast, slow) %>% 
    log() %>% 
    sd() %>% 
    log() %>% 
    signif(4)
sigma_gamma <- 1.0
```


I also simulated some data with $r = \{ 0.25, 0.5, 0.75, 1.25 \}$ to compare the 
simulations to the preliminary data.
Below, "rX" indicates a panel of simulated data with $r$ set to the number X.
The others are the preliminary data.
From these simulations, values of $r > 0.5$ seem pretty unlikely.


```{r load_prior2, fig.height=6}
sim_R <- function(df_, R_, alpha_ = 1/2000) {
    add_row(df_, 
            line = paste0("r", R_), rep = rep(1:5, each=15), 
            date = rep(1:15, 5) + 3,
            X = sim_lines(R = R_, alpha = alpha_, n_reps = 5,
                          nobs_ts = rep(15, 5), sigma_process = exp(tau)) %>% 
                as.numeric())
}

load_prior_data() %>% 
    sim_R(0.25) %>% 
    sim_R(0.5) %>% 
    sim_R(0.75) %>% 
    sim_R(1) %>% 
    sim_R(1.25) %>% 
    mutate(rep = factor(rep)) %>% 
    ggplot(aes(date, X)) +
    geom_line(aes(color = rep)) +
    facet_wrap(~ line, nrow = 3) +
    scale_color_brewer(palette = "Dark2", guide = FALSE)
```



For the among-line mean of the log-transformed growth rates ($\mu_\theta$), 
I used `mean(log(c(fast, slow)))`, `r mu_theta`.
For the standard deviation of $\mu_\theta$ ($\sigma_\theta$),
I used `sd(log(c(fast, slow))) * 10`, `r sigma_theta`.
I multiplied by 10 to add extra uncertainty because of the limited number of lines
from which I derived my priors.
In the plot below, I've exponentiated the x-axis so that it displays the values of
$r$ that would result.


```{r mean_theta_distr}
compare_priors(dlnorm_, mu_theta, sigma_theta, xlim = c(0, 1.25)) +
    geom_vline(xintercept = exp(mu_theta)) +
    ggtitle(expression(italic(r) == plain(exp)(theta %~% plain(N)(
        mu[theta] * "," ~ sigma[theta]^2)))) +
    NULL
```


For sampling $s_\theta$, I use `sd(log(c(fast, slow)))` (`r gamma`) for the location
parameter and `r sigma_gamma` for the scale parameter.
The latter was chosen to indicate even more uncertainty in $s_\theta$ than in
$\mu_\theta$.
Note that below, the x-axis is log-transformed, but axis labels indicate 
non-transformed values.

```{r s_theta_distr}
compare_priors("normal", gamma, sigma_gamma, xlim = gamma + c(-1,1) * 3.25) +
    geom_vline(xintercept = gamma) +
    ggtitle(expression(s[theta] %~% plain("Lognormal")(gamma * "," ~ sigma[gamma]))) +
    scale_x_continuous(breaks = log(c(2 * 10^(-2:0), 0.01, 0.1, 1)),
                       labels = c(2 * 10^(-2:0), 0.01, 0.1, 1)) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_gamma)) +
    NULL
```





## Density dependence


For density dependence, I'm going to use data from preliminary population-growth
assays that used the same methods that we're using.
We conducted these assays on 4 aphid lines that we no longer maintain in the lab
and won't be using for our analyses or cage experiments.

If we look at the deterministic portion of our model...

$$
X_{t+1} = X_t + r \left( 1 - \alpha ~ \text{e}^{X_t} \right)
$$
... $X_{t+1} = X_t$ when $\alpha = 1 / \exp(X_t) = 1 / N_t$.
Because each repetition is run until the plant dies and populations crash,
I'll assume that for each repetition, our estimate of $\alpha$ is $1 / \max(N_t)$.

Here is how I coded it:

```{r load_prior_data_alpha, echo = TRUE}
prior_df <- load_prior_data() %>% 
    group_by(line, rep) %>% 
    summarize(alpha = 1 / max(N)) %>% 
    ungroup()
prior_df
```
```{r logit_funs_and_application}
logit <- function(p) log(p / (1-p))
inv_logit <- function(x) 1 / (1 + exp(-x))
prior_df <- prior_df %>% 
    mutate(logit_alpha = logit(alpha))
```



```{r define_alpha_priors}
# mean and standard deviations of the normal distribution that generates phi values
#   (phi = among-line mean of the logit-transformed density dependences)
mu_phi <- prior_df %>% 
    group_by(line) %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    ungroup() %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    .[["logit_alpha"]] %>% 
    signif(4)
sigma_phi <- prior_df %>% 
    group_by(line) %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    ungroup() %>% 
    summarize(logit_alpha = sd(logit_alpha)) %>% 
    .[["logit_alpha"]] %>% 
    `*`(., 10) %>%
    signif(4)

# - $\delta$: meanlog parameter for the log-normal distribution that generates
#   $s_\phi$ values
# - $\sigma_\delta$: sdlog parameter for the log-normal distribution that generates
#   $s_\phi$ values
# - $\zeta$: meanlog parameter for the log-normal distribution that generates
#   values in $\hat{s}_{\phi}$
# - $\sigma_\zeta$: sdlog parameter for the log-normal distribution that generates
#   values in $\hat{s}_{\phi}$

# meanlog and sdlog parameters for the log-normal distribution that generates
#   s_phi values
#   (s_phi = among-line standard deviation of the logit-transformed density dependences)
delta <- prior_df %>% 
    group_by(line) %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    ungroup() %>% 
    summarize(logit_alpha = sd(logit_alpha)) %>% 
    .[["logit_alpha"]] %>% 
    log() %>% 
    signif(4)
sigma_delta <- 2

# meanlog and sdlog parameters for the log-normal distribution that generates
#   values in hat_s_phi
#   (hat_s_phi = vector of the within-line standard deviations in the logit-transformed
#    density dependences for each aphid line)
zeta <- prior_df %>%
    group_by(line) %>% 
    summarize(logit_alpha = logit_alpha %>% sd() %>% log()) %>% 
    ungroup() %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>%
    .[["logit_alpha"]] %>%
    signif(4)
sigma_zeta <- prior_df %>%
    group_by(line) %>%
    summarize(logit_alpha = logit_alpha %>% sd() %>% log()) %>%
    ungroup() %>%
    summarize(logit_alpha = sd(logit_alpha)) %>%
    .[["logit_alpha"]] %>%
    `*`(., 2) %>%
    signif(4)
```


### Among-line distribution

For estimates relating to the among-line distribution of $\text{logit}(\alpha)$,
I first calculated $\text{logit}(\alpha)$ for each line-rep combo,
then calculated the mean for each line.
After that, I used the mean across lines, `r sprintf("%.3f", mu_phi)`,
as my prior for $\mu_\phi$.
I multiplied the standard deviation across lines by 10 (resulting in `r sigma_phi`)
for my prior on $\sigma_\phi$ to decrease my certainty in estimates.
For the plot below, I inverse-logit transformed the x-axis to show the resulting $\alpha$
values from these priors.
It still has pretty low densities above 0.5, which is reasonable because that
would indicate a "carrying capacity" of < 2.

```{r alpha_overall_mean_plot}
logit_dlnorm <- function(p, location, scale) {
    dnorm(logit(p), location, scale)
}
compare_priors(logit_dlnorm, mu_phi, sigma_phi, xlim = c(0, 1)) +
    geom_vline(xintercept = inv_logit(mu_phi), linetype = 2) +
    ggtitle(expression(alpha == {plain("logit")^{-1}}(
        phi %~% plain(N)(mu[phi] * "," ~ sigma[phi]^2))))
```


For the distribution of $s_\phi$ values, I used the log-transformed SD for among-line 
mean $\text{logit}(\alpha)$ (`r delta`) for the meanlog parameter ($\delta$), and
`r sigma_delta` for the sdlog parameter ($\sigma_\delta$).
The latter was chosen simply because I'm not very sure of what it should be, and 
this value results in a pretty flat prior distribution.
Note that below, the x-axis is log-transformed, but axis labels indicate 
non-transformed values.


```{r alpha_line_means_plot}
compare_priors("normal", delta, sigma_delta, xlim = delta + c(-1,1) * sigma_delta * 3) +
    geom_vline(xintercept = delta) +
    ggtitle(expression(s[phi] %~% plain("Lognormal")(delta * "," ~ sigma[delta]))) +
    scale_x_continuous(breaks = log(10^(-3:2)),
                       labels = 10^(-3:2)) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_delta)) +
    NULL
```



### Within-line distribution

For estimates relating to the *within*-line distribution of $\text{logit}(\alpha)$,
I first calculated $\text{logit}(\alpha)$ for each line-rep combo,
then calculated the standard deviation of these estimates for each line.
After that, I used the mean of log-transformed SD estimates across lines, `r zeta`,
as my prior for $\zeta$.
I used $10 \times$ the SD of log-transformed SD estimates across lines, `r zeta`, 
as my prior for $\zeta$.
This results in the following weakly informative prior:


```{r alpha_within_line_sd_plot}
compare_priors("normal", zeta, sigma_zeta, xlim = zeta + c(-1,1) * sigma_zeta * 3) +
    geom_vline(xintercept = zeta) +
    ggtitle(expression(hat(s)[phi] %~% plain("Lognormal")(zeta * "," ~ sigma[zeta]))) +
    scale_x_continuous(breaks = log(10^(-3:2)),
                       labels = 10^(-3:2)) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_zeta)) +
    NULL
```




# Final priors

```{r priors_table}
data_frame(
    par = c(
        "tau",
        "sigma_tau",
        "mu_theta",
        "sigma_theta",
        "gamma",
        "sigma_gamma",
        "mu_phi",
        "sigma_phi",
        "delta",
        "sigma_delta",
        "zeta",
        "sigma_zeta"
    ),
    value = c(
        tau,
        sigma_tau,
        mu_theta,
        sigma_theta,
        gamma,
        sigma_gamma,
        mu_phi,
        sigma_phi,
        delta,
        sigma_delta,
        zeta,
        sigma_zeta
    )
) %>% 
    knitr::kable(format = "html")


```

