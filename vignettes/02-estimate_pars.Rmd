---
title: "Estimating aphid population parameters"
author: "Lucas A. Nell"
date: "2018-07-03"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating aphid population parameters}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
```

```{r library_pkgs, warning=FALSE, echo=FALSE}
suppressPackageStartupMessages({
    library(clonewars)
    library(stringr)
    library(viridisLite)
})
```


This file contains the analyses to estimate aphid population-growth and
plant-deterioration parameters.


## Imputing missing data

From [Moritz et al. (2015)](https://arxiv.org/abs/1510.03924), the
seasonal kalman filter from the `zoo` package works well, so I used this function
to impute missing values.
We're only missing 1 or 2 time points across a time series of >15, so this
shouldn't have too big an impact on our results.


## Load data

```{r load_data}
growth <- 
    load_data(filter_pars = list(start = 0, end = 0.5)) %>%
    # Now filter out early part of each time series, before N > 6
    # N <= 6 is when the stochasticity associated with only starting with 2 adults
    # appears to be strongest
    group_by(line, rep) %>% 
    filter(1:n() >= which(N > 6)[1]) %>%
    mutate(date = as.integer(date - min(date))) %>%
    ungroup() %>% 
    identity()
```

This is how many reps I have of each line:

```{r view_reps, echo=FALSE}
growth %>% 
    group_by(line) %>% 
    summarize(n = rep %>% unique() %>% length()) %>% 
    knitr::kable()
n_ts <- growth %>%
    distinct(line, rep) %>%
    nrow()
```




## See time series data

```{r plot_time_series, echo = FALSE}
growth_plot <- growth %>% 
    group_by(line) %>% 
    mutate(rep = map_int(rep, ~ which(sort(unique(rep)) == .x))) %>% 
    ungroup() %>% 
    mutate(rep = factor(rep),
           # line = factor(sprintf("line %s", LETTERS[as.integer(line)]))) %>% 
           NULL) %>% 
    ggplot(aes(date, X, color = rep)) +
    geom_line(size = 0.75) +
    geom_point(size = 0.75) +
    facet_wrap(~ line, nrow = 2) +
    scale_color_brewer(palette = "RdBu", guide = FALSE) +
    scale_y_continuous("Aphid abundance", breaks = log(10^(1:3)),
                       labels = 10^(1:3)) +
    scale_x_continuous("Time (days)", breaks = seq(0, 20, 10)) +
    NULL
growth_plot
# ggsave("~/Desktop/growth_plot.pdf", growth_plot, width = 5, height = 4)
```






## Run model

```{r run_model, eval = FALSE}
# Takes ~ 2.5 min
stan_fit <- fit_lines(growth, model_name = "full_model_plant_death",
                      seed = 1337925041)
```
```{r write_model, eval = FALSE, echo = FALSE}
write_rds(stan_fit, "inst/extdata/stan_fit.rds")
```
```{r read_model, eval = TRUE, echo = FALSE}
stan_fit <- read_rds("inst/extdata/stan_fit.rds")
```
```{r model_posterior_preds, echo = FALSE}
posterior <- as.array(stan_fit)
pred_df <- make_pred_df(stan_fit, growth)
```


## Examine model performance



Residuals vs. predicted X:

```{r resid_pred, echo = FALSE}
growth %>% 
    arrange(line, rep, date) %>% 
    select(obs = X) %>% 
    mutate(pred = apply(rstan::extract(stan_fit, "X_pred", permuted = FALSE),
                        3, median),
           resid = apply(rstan::extract(stan_fit, "X_resid", permuted = FALSE),
                        3, median)) %>%
    ggplot(aes(pred, resid)) +
    geom_point(shape = 1, alpha = 0.5) +
    geom_abline(slope = 0, intercept = 0, color = "dodgerblue", linetype = 2,
                size = 1) +
    xlab("predicted X") +
    ylab("residual") +
    NULL
```


Correlations between parameter estimates:

```{r est_cors, echo = FALSE}
names_iwant <- c("lp__", "sigma_epsilon", "rho", "sigma_rho", "phi", "sigma_phi")
cor_df <- rstan::extract(stan_fit, names_iwant) %>% 
    lapply(as_data_frame) %>% 
    bind_cols() %>% 
    set_names(names_iwant)
GGally::ggpairs(cor_df) + 
    theme(strip.text = element_text(size = 10, lineheight = 2,
                                    hjust = 0.5, vjust = 1))

names_iwant <- c("lp__",  names(stan_fit)[grepl("^zetas", names(stan_fit))])
cor_df <- rstan::extract(stan_fit, names_iwant) %>% 
    lapply(as_data_frame) %>% 
    bind_cols() %>% 
    set_names(names_iwant)

sapply(names_iwant[names_iwant != "lp__"], function(x) cor(cor_df[[x]], cor_df$lp__)) %>% range()
```



R-hat values are all well below 1.05:

```{r r_hats, echo = FALSE}
# Indices for when new time series start (we don't want to plot diagnostics on these
# bc their values are constant):
new_ts <- c(1,
            growth %>% 
                {which(.$line != lag(.$line) | .$rep != lag(.$rep))})
bayesplot::rhat(stan_fit) %>% 
    {
        # Converting to regex strings:
        regex <- paste(c(sprintf("X_hat_pred\\[%i\\]", new_ts),
                         sprintf("X_resid\\[%i\\]", new_ts),
                         sprintf("X_pred\\[%i\\]", new_ts)),
                       collapse = "|")
        inds <- str_detect(names(.), regex)
        .[!inds]
    } %>% 
    {tibble(par = names(.), rhat = .)} %>% 
    ggplot(aes(rhat)) +
    geom_histogram(bins = 50, fill = viridis(1, begin = 0.95)) +
    scale_x_continuous(expression(hat(R)))
```


Most ratios of effective sample sizes are near 1.

```{r neffs_all, echo = FALSE}
bayesplot::neff_ratio(stan_fit) %>% 
    {
        # Converting to regex strings:
        regex <- paste(c(sprintf("X_hat_pred\\[%i\\]", new_ts),
                         sprintf("X_resid\\[%i\\]", new_ts),
                         sprintf("X_pred\\[%i\\]", new_ts)),
                       collapse = "|")
        inds <- str_detect(names(.), regex)
        .[!inds]
    } %>% 
    {tibble(par = names(.), neff = .)} %>% 
    ggplot(aes(neff)) +
    geom_histogram(bins = 50, fill = viridis(1, begin = 0.8)) +
    xlab(expression(N[eff]/N))
```


A few are pretty low, but none have less than 400 useful reps overall, so I'm not too
worried.

```{r neffs_lowest, echo = FALSE}
bayesplot::neff_ratio(stan_fit) %>% 
    {
        # Converting to regex strings:
        regex <- paste(c(sprintf("X_hat_pred\\[%i\\]", new_ts),
                         sprintf("X_resid\\[%i\\]", new_ts),
                         sprintf("X_pred\\[%i\\]", new_ts)),
                       collapse = "|")
        inds <- str_detect(names(.), regex)
        .[!inds]
    } %>%
    keep(~ .x < 0.25) %>% 
    {tibble(par = names(.) %>% factor(), neff = .)} %>% 
    ggplot(aes(neff, par)) +
    geom_vline(xintercept = 0.1, linetype = 2, color = "gray80") +
    geom_segment(aes(xend = 0, yend = par),
                 color = viridis(1, begin = 0.8)) +
    geom_point(color = viridis(1, begin = 0.8)) +
    xlab(expression(N[eff]/N)) +
    ylab(NULL)
```



From predicted values for each time series, plots of per-capita growth
versus abundance appear to show mostly negative trends,
which is good because this indicates density dependence.


```{r pred_pcg, echo = FALSE}
pred_df %>%
    group_by(line, rep) %>% 
    mutate(pcg = X_pred - lag(X_pred)) %>% 
    ungroup() %>% 
    ggplot(aes(exp(X_pred), pcg)) +
    geom_hline(yintercept = 0, linetype = 2, color = "gray80") +
    geom_line(color = viridis(1, begin = 0.8)) +
    stat_smooth(method = "lm", geom = "line", se = FALSE, na.rm = TRUE,
                color = viridis(1, begin = 0.1), linetype = 1) +
    facet_wrap(~ rep + line, nrow = 6) +
    theme(strip.text = element_blank(), panel.border = element_rect(fill = NA)) +
    scale_x_continuous("N", breaks = c(0, 500)) +
    ylab("Per-capita growth rate") +
    NULL
```



## Model estimates

Estimates of R for each line:

```{r R_estimates, echo = FALSE, message = FALSE}
# http://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html
R_p <- bayesplot::mcmc_intervals(posterior, pars = sprintf("R[%i]", 1:8)) +
    scale_y_discrete(labels = growth$line %>% levels()) +
    xlab("Growth rate")
R_p
# ggsave("~/Desktop/R_plot.pdf", R_p, width = 4, height = 5)
```


Estimates for density dependence:

```{r A_estimates, echo = FALSE, message = FALSE}
A_p <- bayesplot::mcmc_intervals(posterior, pars = sprintf("A[%i]", 1:8)) +
    scale_y_discrete(labels = growth$line %>% levels()) +
    xlab("Density dependence")
A_p
# ggsave("~/Desktop/A_plot.pdf", A_p, width = 4, height = 5)

# Probably a better, simpler plot going forward:
# rstan::extract(stan_fit, "R", permuted = FALSE) %>% 
#     apply(3, c) %>% 
#     apply(2, quantile, probs = c(0.025, 0.5, 0.975)) %>%
#     t() %>%
#     as.data.frame() %>% 
#     as_tibble() %>%
#     set_names(c("low", "med", "high")) %>% 
#     mutate(line = stan_estimates$names) %>%
#     select(line, everything()) %>% 
#     ggplot(aes(line)) +
#     geom_linerange(aes(ymin = low, ymax = high)) +
#     geom_point(aes(y = med)) +
#     coord_flip() +
#     ylab("Growth rate") +
#     theme(axis.text.y = element_text(size = 11, color = "black"),
#           axis.title.y = element_blank()) +
#     NULL

```


Estimates for zeta (for each plant):

```{r A_estimates, echo = FALSE, message = FALSE}
Z_p <- rstan::extract(stan_fit, sprintf("zetas[%i]", 1:n_ts)) %>% 
    map_dbl(~median(.x)) %>% 
    enframe(name = NULL) %>% 
    ggplot(aes(value)) +
    geom_histogram(bins = 20, fill = viridis(1, begin = 0.1)) +
    xlab(expression(zeta)) +
    theme(axis.title.x = element_text(size = 16))
Z_p
# ggsave("~/Desktop/Z_plot.pdf", Z_p, width = 4, height = 4)
```


Other estimates of interest:

```{r other_estimates}
other_pars <- names(stan_fit)
other_pars <- other_pars[!grepl("^Z", other_pars) &
                             !grepl("^X", other_pars) &
                             !grepl("^zetas", other_pars) &
                             !grepl("^A", other_pars) &
                             !grepl("^R", other_pars) &
                             other_pars != "sigma_hat_epsilon"]

op_expr <- other_pars %>% 
    {ifelse(grepl("^sigma_", .), paste0(gsub("_", "[", .), "]"), .)} %>% 
    {ifelse(. == "lp__", "log ~ posterior", .)}

rstan::extract(stan_fit, other_pars) %>%
    lapply(as_tibble) %>% 
    bind_cols() %>% 
    set_names(other_pars) %>% 
    gather("par", "value") %>% 
    mutate(par = factor(par, levels = other_pars, labels = op_expr)) %>% 
    ggplot(aes(value)) +
    geom_density(color = viridis(1, begin = 0.5)) +
    facet_wrap(~ par, nrow = 3, scales = "free", labeller = label_parsed)
```


```{r prefixes, eval = FALSE, echo = FALSE}
# In case you're interested in seeing possible names to look at (without
# having huge list that includes every X_pred[<i>])
prefixes <- names(stan_fit) %>% 
    {
        i <- stringr::str_locate(., "\\[") %>% 
            .[,1] %>%
            as.integer()
        ifelse(is.na(i), ., stringr::str_sub(., 1, i - 1))
    } %>% 
    unique()
```




## Model predictions

Model prections (minus process error; blue with gray envelopes) and observed
abundances (red lines and dots).

```{r predictions, fig.height=10, fig.width=6}
pred_df %>%
    ggplot(aes(date, X)) +
    geom_ribbon(aes(ymin = X_lower, ymax = X_upper),
                fill = "gray70", alpha = 0.5) +
    geom_line(color = "firebrick", alpha = 0.5) +
    geom_point(shape = 1, color = "firebrick", alpha = 0.5) +
    geom_line(aes(y = X_pred), color = "dodgerblue3", size = 0.5) +
    facet_wrap(~ rep + line, nrow = 6) +
    theme(strip.text = element_blank()) +
    xlab("Date") +
    ylab("log(N)") +
    NULL
```


Below is predicted growth across a time series for each aphid line.
The dashed line shows the value $\exp (\zeta)$ that gets multiplied by each line's alpha.
This value corresponds to the effect of deteriorating plant health through time.

```{r predictions_byline}
# Instead of this, make plot of predicted growth through time
Z_ <- rstan::extract(stan_fit, sprintf("Z[%i]", 1:n_ts)) %>% 
    sapply(median) %>% 
    mean()
mu_time <- rstan::extract(stan_fit, "mu_time") %>%
    sapply(median) %>% set_names(NULL)
R_ <- rstan::extract(stan_fit, sprintf("R[%i]", 1:8)) %>% 
    sapply(median)
A_ <- rstan::extract(stan_fit, sprintf("A[%i]", 1:8)) %>% 
    sapply(median)

ricker <- function(time, R, A, X0 = log(6)) {
    X <- numeric(length(time))
    X[1] <- X0
    for (t in 2:length(time)) {
        X[t] <- X[t-1] + R * (1 - A * exp(Z_ * (time[t] - mu_time) + X[t-1]))
    }
    return(X)
}


max_t <- 20
pred_growth <- tibble(time = rep(1:max_t, 8),
           line = factor(rep(levels(growth$line), each = max_t)),
           R = rep(R_, each = max_t),
           A = rep(A_, each = max_t)) %>% 
    group_by(line) %>% 
    mutate(X = ricker(time, R[1], A[1])) %>% 
    ungroup()

mult <- exp(max(pred_growth$X)) / exp(Z_ * (max(pred_growth$time) - mu_time))

pred_p <- pred_growth %>% 
    ggplot(aes(time, exp(X), color = line)) +
    geom_ribbon(data = pred_growth %>% distinct(time),
              aes(ymin = 0, ymax = exp(Z_ * (time - mu_time)) * mult, y = NULL),
              linetype = 2, color = NA, fill = "gray80") +
    geom_line(size = 0.75) +
    geom_text(data = pred_growth %>% 
                  group_by(line) %>%
                  summarize(time = max_t + 0.5, X = tail(X, 1)),
              aes(label = line), hjust = 0, fontface = "bold", size = 3.5) +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    scale_x_continuous("Time", limits = c(0, max_t + 5)) +
    scale_y_continuous("N", sec.axis = sec_axis(~ ./ mult, name = expression(exp(zeta)))) +
    NULL

pred_p
# ggsave("~/Desktop/pred_plot.pdf", pred_p, width = 8, height = 6)
```

