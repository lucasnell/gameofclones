---
title: "Estimating dispersal"
author: "Lucas A. Nell"
date: "2018-07-03"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating dispersal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 4L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
```

```{r library_pkgs, warning=FALSE, echo=TRUE}
suppressPackageStartupMessages({
    library(clonewars)
    library(lme4)
})
logit <- function(p) {
    suppressWarnings({x <- log(p/(1 - p))})
    # x <- ifelse(is.nan(x), NA, x)
    return(x)
}
inv_logit <- function(x) {
    p <- 1 / (1 + exp(-x))
    p <- ifelse(is.na(p) & !is.na(x), 1, p)
    return(p)
}
```


This file contains the analyses to estimate aphid dispersal.



## Load data

I don't need to do the same filtering when loading the dataset for dispersal estimates
as when loading data for population-growth parameter estimation.
The only filtering I need to do is removing (1) a weird rep for line "Clover-2017-2" (when
one adult just stayed on the side of the cage until it died)
and (2) the first day of counts if both individuals were on the ground.


```{r load_data}
growth <- load_data(filter_pars = NULL,
                    remove_unfinished = FALSE) %>% 
    filter(date != 0, 
           !(line == "Clover-2017-2" & rep == 1),
           !is.na(X), !is.na(N), !is.na(disp)) %>% 
    mutate(
        rep = factor(rep),
        # For overdispersion:
        od = 1:n(),
        # For binomial of whether dispersal is > 0:
        disp_b = ifelse(disp > 0, 1, 0)
        )
```


## View sample sizes

Below, `n_d` is the number of days where the number of dispersed individuals was
greater than zero.

```{r}
growth %>% 
    group_by(line) %>% 
    summarize(n = rep %>% unique() %>% length(),
              n_d = sum(disp > 0)) %>% 
    knitr::kable()
```



## Dispersal ~ N plot

Below, colors represent different reps.


```{r disp_N_plot}
growth %>%
    filter(disp > 0) %>% 
    ggplot(aes(N, disp, color = rep)) +
    geom_point(shape = 16, alpha = 0.5) +
    # stat_summary_bin(geom = "line", binwidth = 100, fun.y = mean, color = "black") +
    # stat_smooth(method = "glm", se = FALSE, color = "black", formula = y ~ poly(x, 2),
    #             method.args = list(family = "poisson")) +
    facet_wrap(~ line) +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    scale_fill_brewer(palette = "Dark2", guide = FALSE) +
    # scale_x_continuous(breaks = 10^(0:3), trans = "log") +
    scale_y_continuous(breaks = 4^(0:3), trans = "log") +
    # coord_trans(y = "log1p") +
    NULL
```


## Fitting GLMMM

Fitting a GLMM of `dispersal ~ X` (`X = log(N)`) where each line
(and each `rep` within `line`) gets a separate intercept and slope.
I'm doing this for now even though the AIC for this is actually higher
than when the random effect is `(X | line:rep)` because I want line-specific
estimates.
Because I don't yet have my full dataset, I'm going to just use this information
for the simulations without worrying about how much statistical evidence
there is that lines are actually different.
This will obviously change once I have all 10 reps for each line.
I added `(1 | od)` to account for overdispersion.


```{r fit_glmm}
# Chances of dispersal > 0 as a function of the # aphids on the plant:
disp_mod <- glmer(disp_b ~ poly(N,2) + (1 | line/rep), data = growth,
                  family = "binomial",
                  control = glmerControl(optimizer = "bobyqa", 
                                         optCtrl = list(maxfun = 2e4)))
# Number of aphids dispersed as a function of the aphid line, with terms for
# "effort" (log(# aphids)) and overdispersion
disp_mod2 <- growth %>% 
    filter(disp > 0) %>% 
    {glmer(disp ~ 1 + (1 | line) + offset(X) + (1 | od),
              data = ., family = "poisson")}
disp_mod %>% summary()
disp_mod2 %>% summary()
```


Estimates for each line:

<!---
*************************
*************************

THE REMAINDER OF THE DOCUMENT IS NOT UPDATED FOR THE NEW MODELS

*************************
*************************
-->

```{r make_disp_mod_df}
disp_estimates <- disp_mod %>% 
    ranef() %>% 
    .[["line"]] %>% 
    set_names(NULL) %>% 
    {cbind(inter = ., N1 = rep(0, length(.)), N2 = rep(0, length(.)))} %>% 
    `+`({
        disp_mod %>%
            fixef() %>% 
            rep(growth$line %>% levels() %>% length()) %>% 
            matrix(ncol = length(disp_mod %>% fixef()), byrow = TRUE)
    }) %>% 
    rownames_to_column("line")
disp_estimates %>% 
    knitr::kable(digits = 3)
```


Overdispersion estimate:

```{r make_disp_mod_df}
# disp_od <- 
disp_mod %>% str()
# od       (Intercept) 2.3872
# rep:line (Intercept) 4.7242

VarCorr(disp_mod) %>% 
    as.data.frame() %>% 
    filter(grp != "line")

z <- disp_mod %>% 
    ranef() %>%
    .[["rep:line"]]

hist(z[,1])


```



Code to make predictions from `disp_mod` based on a vector of `X` and aphid line
names:

```{r prediction_fxn}
predict_disp <- function(N, aphid_line) {
    inds <- map_int(aphid_line, ~ which(disp_estimates$line == .x))
    
    N_poly2 <- poly(N, 2, coefs = attr(poly(growth$N, 2), "coefs"))
    x_mat <- cbind(rep(1, length(N)), N_poly2)
    
    beta_mat <- cbind(disp_estimates$inter[inds],
                      disp_estimates$N1[inds],
                      disp_estimates$N2[inds])
    y <- inv_logit(rowSums(beta_mat * x_mat))
    return(y)
}
```


## Plotting predictions

```{r glmm_prediction_plot}
growth %>% 
    mutate(disp_pred = predict_disp(N, line)) %>%
    # mutate(disp_pred = predict(disp_mod, type = "response")) %>%
    ggplot(aes(N, disp_pred, color = rep)) +
    geom_point(aes(y = disp_b), alpha = 0.5, shape = 16) +
    geom_line(size = 0.75, color = "black") +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    # scale_y_continuous("Dispersed aphids", trans = "log1p",
    #                    breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    # coord_cartesian(ylim = c(0, 10)) +
    NULL
```



## Saving output

```{r save_output, eval = FALSE}
devtools::use_data(disp_estimates, overwrite = TRUE)
```

