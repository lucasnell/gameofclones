---
title: "Estimating dispersal"
author: "Lucas A. Nell"
date: "2018-07-03"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating dispersal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
```

```{r library_pkgs, warning=FALSE, echo=TRUE}
suppressPackageStartupMessages({
    library(MASS)
    library(clonewars)
    library(lme4)
})
logit <- function(p) {
    suppressWarnings({x <- log(p/(1 - p))})
    # x <- ifelse(is.nan(x), NA, x)
    return(x)
}
inv_logit <- function(x) {
    p <- 1 / (1 + exp(-x))
    p <- ifelse(is.na(p) & !is.na(x), 1, p)
    return(p)
}
```


This file contains the analyses to estimate aphid dispersal.



## Load data

I don't need to do the same filtering when loading the dataset for dispersal estimates
as when loading data for population-growth parameter estimation.
The only filtering I need to do is removing the first day of counts when both
individuals were on the ground.


```{r load_data}
growth <- load_data(filter_pars = NULL,
                    remove_unfinished = FALSE) %>% 
    filter(date != 0) %>% 
    mutate(rep = factor(rep))
```


```{r growth_manip}
growth <- growth %>% 
    group_by(line, rep) %>% 
    arrange(date) %>% 
    mutate(disp = ifelse(is.na(disp), 0, disp),
           N = round(impute(N)),
           X = log(N),
           pN = N - disp,  # numbers of aphids on plant
           dD = disp - lag(disp, default = 0),
           dD = ifelse(dD < 0, 0, dD),
           date_ = which(date == max(date)) - date) %>% 
    ungroup() %>% 
    arrange(line, rep, date) %>% 
    identity()
```


## View sample sizes

Below, `n_d` is the number of days where the number of dispersed individuals was
greater than zero.

```{r n_d_table}
growth %>% 
    group_by(line) %>% 
    summarize(n = rep %>% unique() %>% length(),
              n_d = sum(disp > 0)) %>% 
    knitr::kable()
```



## Dispersal ~ N plot

Below, colors represent different reps.


```{r disp_N_plot, warning=FALSE}
growth %>%
    ggplot(aes(N, disp, color = rep)) +
    geom_point(shape = 16, alpha = 0.5) +
    stat_smooth(data = growth %>% filter(disp > 0),
                method = glm.nb, se = FALSE, color = "black",
                formula = y ~ 1 + offset(log(x))) +
    facet_wrap(~ line) +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    scale_fill_brewer(palette = "Dark2", guide = FALSE) +
    scale_y_continuous(breaks = 4^(0:3)) +
    coord_trans(y = "log1p") +
    NULL
```


## Fitting GLMMM

Fitting a GLMM of `dispersal ~ X` (`X = log(N)`) where each line
(and each `rep` within `line`) gets a separate intercept and slope.
I'm doing this for now even though the AIC for this is actually higher
than when the random effect is `(X | line:rep)` because I want line-specific
estimates.
Because I don't yet have my full dataset, I'm going to just use this information
for the simulations without worrying about how much statistical evidence
there is that lines are actually different.
This will obviously change once I have all 10 reps for each line.
I added `(1 | od)` to account for overdispersion.


```{r fit_glmm, warning=FALSE}
# Whether dispersed as a function of line and N and N^2:
disp_binom <- glm(disp_b ~ 0 + line + N + I(N^2),
                  data = growth, family = binomial)
# Number dispersed as function of line with X as offset:
disp_nb <- glm.nb(disp ~ 0 + line + offset(X),
                  data = filter(growth, disp > 0))
disp_binom %>% summary()
disp_nb %>% summary()
```



Theta estimate for the negative binomial regression:

```{r make_disp_od}
disp_nb$theta
```


Estimates for each line:


```{r make_disp_mod_df, echo = FALSE}
disp_estimates <-
    list(
        binom = disp_binom %>%
            coef() %>% 
            {names(.) <- gsub("line", "", names(.)); .} %>% 
            {cbind(head(., -2), 
                   rep(tail(., 2)[1], length(.)-2), 
                   rep(tail(., 1), length(.)-2))} %>% 
            as.data.frame() %>% 
            set_names(c("inter", "N1", "N2")) %>% 
            rownames_to_column("line"),
        nb = disp_nb %>% 
            coef() %>% 
            {names(.) <- gsub("line", "", names(.)); .} %>% 
            cbind() %>% 
            as.data.frame() %>% 
            set_names("inter") %>% 
            rownames_to_column("line") %>% 
            mutate(theta = disp_nb$theta)
    )
if (!identical(disp_estimates$binom$line, disp_estimates$nb$line)) {
    stop("line columns should be identical in both parts of disp_estimates list.")
}

disp_estimates %>% 
    map( ~ mutate_if(.x, is.numeric, sprintf, fmt = "%.3g")) %>% 
    knitr::kable(
        format = "html",
        caption = paste("Model estimates for the binomial GLM (top) and",
                        "Negative binomial GLM (bottom), for each line.")
        )
```




Code to make predictions from both models based on a vector of `N` and aphid line
names:

```{r prediction_fxn}
predict_disp <- function(N, aphid_line) {
    inds <- map_int(aphid_line, ~ which(disp_estimates$binom$line == .x))
    # Binomial estimate (Pr(dispersal > 0)):
    b0 <- disp_estimates$binom$inter[inds]
    b1 <- disp_estimates$binom$N1[inds]
    b2 <- disp_estimates$binom$N2[inds]
    pr_disp <- inv_logit(b0 + b1 * N + b2 * N^2)
    # Negative binomial estimate (# dispersed | dispersal occurs):
    b0 <- disp_estimates$nb$inter[inds]
    n_disp <- exp(b0) * N
    return(pr_disp * n_disp)
}
```


## Plotting predictions

```{r glmm_prediction_plot}
growth %>% 
    ggplot(aes(N, disp, color = rep)) +
    geom_point(alpha = 0.5, shape = 16) +
    geom_line(data = expand.grid(N = 1:1000,
                                 line = growth$line %>% unique() %>% sort()) %>% 
                  mutate(disp = predict_disp(N, line)),
        size = 0.75, color = "black") +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    scale_y_continuous("Dispersed aphids", trans = "log1p",
                       breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    NULL
```


## Testing simulation

```{r sim_disp}
sim_disp <- function(N, aphid_line) {
    inds <- map_int(aphid_line, ~ which(disp_estimates$binom$line == .x))
    n <- length(N)
    # Binomial estimate (Pr(dispersal > 0)):
    b0 <- disp_estimates$binom$inter[inds]
    b1 <- disp_estimates$binom$N1[inds]
    b2 <- disp_estimates$binom$N2[inds]
    pr_disp <- inv_logit(b0 + b1 * N + b2 * N^2)
    binom_rnd <- rbinom(n, 1, pr_disp)
    # Negative binomial estimate (# dispersed | dispersal occurs):
    b0 <- disp_estimates$nb$inter[inds]
    mu <- exp(b0) * N
    theta <- disp_estimates$nb$theta[inds]
    nb_rnd <- rnbinom(n, size = theta, mu = mu)
    return(binom_rnd * nb_rnd)
}
```



```{r}
growth %>% 
    mutate(disp_ = sim_disp(N, line)) %>% 
    ggplot(aes(N, disp_, color = rep)) +
    geom_point(alpha = 0.5, shape = 16) +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    scale_y_continuous("Dispersed aphids", trans = "log1p",
                       breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    NULL
# Other one to compare to:
growth %>% 
    ggplot(aes(N, disp, color = rep)) +
    geom_point(alpha = 0.5, shape = 16) +
    scale_color_brewer(palette = "Dark2", guide = FALSE) +
    facet_wrap(~ line, nrow = 2) +
    scale_y_continuous("Dispersed aphids", trans = "log1p",
                       breaks = c(0, 4^(0:3))) +
    scale_x_continuous("Total aphids") +
    NULL
```



## Saving output

```{r save_output, eval = FALSE}
devtools::use_data(disp_estimates, overwrite = TRUE)
```

